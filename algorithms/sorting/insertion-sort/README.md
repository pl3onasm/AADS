# Insertion Sort

Insertion sort is an in-place comparison sort which sorts an array $A[0:n-1]$ in ascending order in a similar manner to how we sort a hand of cards. We start with an empty left hand and the cards face down on the table. We then remove one card at a time from the pile on the table and insert it into the correct position in the left hand. To find the correct position for a card, we compare it with each of the cards already in the hand, from right to left, until we find a card that is smaller than it, or until we reach the left end of the hand. At that point, the card we are trying to insert is placed into the position immediately to the right of the card that is smaller than it, or at the left end of the hand if all cards in the hand are larger than it.

At each iteration, the left subarray is sorted and we insert the next element from the right unsorted subarray into the correct position in the left subarray. This is repeated until the entire array is sorted. If we were to implement insertion sort recursively, we would have a base case of an array of size 1, which is trivially sorted. The recursive case would be to sort the left subarray and then insert the last element of the right subarray into the correct position in the left subarray, resulting in a recurrence relation of the form $T(n) = T(n-1) + \Theta(n)$, which has a solution of $O(n^2)$. The worst-case running time of $O(n^2)$ occurs when the array is sorted in reverse order. The best-case running time, however, is $O(n)$, which occurs when the array is already sorted.

Like bubble sort, insertion sort is a stable sort, since it inserts elements that are equal to each other in the same order as they appear in the input array. Note that this is true because we use the strict greater-than operator in the inner loop. If we had used the greater-than-or-equal-to operator, insertion sort would have been unstable.

Implementation: [Insertion sort](https://github.com/pl3onasm/CLRS/tree/main/algorithms/sorting/insertion-sort)
